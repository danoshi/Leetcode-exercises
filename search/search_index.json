{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LeetCode Solutions and Algorithms","text":""},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>This documentation contains solutions and explanations for various LeetCode problems, along with implementations of common data structures and algorithms.</p>"},{"location":"#repository-structure","title":"Repository Structure","text":"<ul> <li>Array Problems: Collection of array-related LeetCode problems</li> <li>String Problems: String manipulation and processing problems</li> <li>Math Problems: Mathematical algorithms and solutions</li> <li>Sorting &amp; Searching: Implementation of various sorting and searching algorithms</li> <li>Data Structures &amp; Algorithms: Implementation of fundamental data structures and algorithms</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To run the code locally:</p> <pre><code>git clone &lt;repository-url&gt;\npip install -r requirements.txt\npytest tests/\n</code></pre>"},{"location":"#test-results","title":"Test Results","text":"<pre><code>============================= test session starts ==============================\nplatform linux -- Python 3.12.9, pytest-8.3.5, pluggy-1.5.0 -- /opt/hostedtoolcache/Python/3.12.9/x64/bin/python\ncachedir: .pytest_cache\nrootdir: /home/runner/work/Leetcode-exercises/Leetcode-exercises\nconfigfile: pyproject.toml\nplugins: cov-6.0.0\ncollecting ... collected 71 items\n\ntests/array_problems/test_best_time_to_buy_and_sell_stock_ll.py::TestSolution::test_max_profit_a PASSED [  1%]\ntests/array_problems/test_contains_duplicate.py::TestSolution::test_containsDuplicate PASSED [  2%]\ntests/array_problems/test_height_checker.py::TestSolution::test_heightChecker PASSED [  4%]\ntests/array_problems/test_intersection_of_two_arrays_ll.py::TestSolution::test_intersect PASSED [  5%]\ntests/array_problems/test_max_consecutive_ones.py::TestSolution::test_findMaxConsecutiveOnes PASSED [  7%]\ntests/array_problems/test_move_zeroes.py::TestSolution::test_moveZeroes PASSED [  8%]\ntests/array_problems/test_plus_one.py::TestSolution::test_plusOne_multiple_digits_no_carry PASSED [  9%]\ntests/array_problems/test_plus_one.py::TestSolution::test_plusOne_multiple_digits_with_carry PASSED [ 11%]\ntests/array_problems/test_plus_one.py::TestSolution::test_plusOne_single_digit_no_carry PASSED [ 12%]\ntests/array_problems/test_plus_one.py::TestSolution::test_plusOne_single_digit_with_carry PASSED [ 14%]\ntests/array_problems/test_remove_duplicates_from_sorted_array.py::TestSolution::test_removeDuplicates PASSED [ 15%]\ntests/array_problems/test_remove_element.py::TestSolution::test_removeElement PASSED [ 16%]\ntests/array_problems/test_replace_elements_with_greatest_element_on_right_side.py::TestSolution::test_replaceElements PASSED [ 18%]\ntests/array_problems/test_rotate_array.py::TestSolution::test_rotate PASSED [ 19%]\ntests/array_problems/test_single_number.py::TestSolution::test_singleNumber PASSED [ 21%]\ntests/array_problems/test_sort_array_by_parity.py::TestSolution::test_sortArrayByParity PASSED [ 22%]\ntests/array_problems/test_squares_of_a_sorted_array.py::TestSolution::test_sortedSquares PASSED [ 23%]\ntests/array_problems/test_two_sum.py::test_two_sum PASSED                [ 25%]\ntests/array_problems/test_two_sum.py::test_two_sum_no_solution PASSED    [ 26%]\ntests/frontendmasters/test_algorithms_pathfinding_dijkstra.py::TestSolution::test_pathfinding PASSED [ 28%]\ntests/frontendmasters/test_algorithms_recursion.py::TestSolution::test_recursion PASSED [ 29%]\ntests/frontendmasters/test_algorithms_searching_binary_search.py::TestSolution::test_binarysearch PASSED [ 30%]\ntests/frontendmasters/test_algorithms_searching_linear_search.py::TestLinearSearch::test_linear_search PASSED [ 32%]\ntests/frontendmasters/test_algorithms_searching_linear_search.py::TestLinearSearch::test_linear_search_empty_list PASSED [ 33%]\ntests/frontendmasters/test_algorithms_searching_linear_search.py::TestLinearSearch::test_linear_search_multiple_elements PASSED [ 35%]\ntests/frontendmasters/test_algorithms_searching_linear_search.py::TestLinearSearch::test_linear_search_single_element PASSED [ 36%]\ntests/frontendmasters/test_algorithms_sorting_bubble_sort.py::TestSolution::test_bubble_sort PASSED [ 38%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_duplicates_array PASSED [ 39%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_empty_array PASSED [ 40%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_large_numbers PASSED [ 42%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_mixed_numbers PASSED [ 43%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_negative_numbers PASSED [ 45%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_reverse_sorted_array PASSED [ 46%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_single_element_array PASSED [ 47%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_sorted_array PASSED [ 49%]\ntests/frontendmasters/test_algorithms_sorting_heap_sort.py::TestSolution::test_unsorted_array PASSED [ 50%]\ntests/frontendmasters/test_algorithms_sorting_insertion_sort.py::TestSolution::test_insertion_sort PASSED [ 52%]\ntests/frontendmasters/test_algorithms_sorting_merge_sort.py::TestSolution::test_mergesort PASSED [ 53%]\ntests/frontendmasters/test_algorithms_sorting_quick_sort.py::TestSolution::test_quicksort PASSED [ 54%]\ntests/frontendmasters/test_algorithms_sorting_radix_sort.py::TestSolution::test_radixSort PASSED [ 56%]\ntests/frontendmasters/test_algorithms_tree_traversal_breadth_first.py::TestSolution::test_breadthFirstTreeTraversals_iterative PASSED [ 57%]\ntests/frontendmasters/test_algorithms_tree_traversal_breadth_first.py::TestSolution::test_breadthFirstTreeTraversals_recursion PASSED [ 59%]\ntests/frontendmasters/test_algorithms_tree_traversal_depth_first.py::TestSolution::test_inorder_traversal PASSED [ 60%]\ntests/frontendmasters/test_algorithms_tree_traversal_depth_first.py::TestSolution::test_postorder_traversal PASSED [ 61%]\ntests/frontendmasters/test_algorithms_tree_traversal_depth_first.py::TestSolution::test_preorder_traversal PASSED [ 63%]\ntests/frontendmasters/test_data_structures_arrays_array_list.py::TestSolution::test_add PASSED [ 64%]\ntests/frontendmasters/test_data_structures_graphs.py::TestSolution::test_find_most_common_title PASSED [ 66%]\ntests/frontendmasters/test_data_structures_linked_lists_singly_linked.py::TestSolution::test_linkedlist PASSED [ 67%]\ntests/frontendmasters/test_data_structures_probabilistic_bloom_filter.py::TestBloomFilter::test_absence PASSED [ 69%]\ntests/frontendmasters/test_data_structures_probabilistic_bloom_filter.py::TestBloomFilter::test_add_and_contains PASSED [ 70%]\ntests/frontendmasters/test_data_structures_probabilistic_bloom_filter.py::TestBloomFilter::test_false_positive PASSED [ 71%]\ntests/frontendmasters/test_data_structures_trees_avl_tree.py::TestSolution::test_add PASSED [ 73%]\ntests/frontendmasters/test_data_structures_trees_avl_tree.py::TestSolution::test_balance PASSED [ 74%]\ntests/frontendmasters/test_data_structures_trees_avl_tree.py::TestSolution::test_serialize PASSED [ 76%]\ntests/frontendmasters/test_data_structures_trees_avl_tree.py::TestSolution::test_to_json PASSED [ 77%]\ntests/frontendmasters/test_data_structures_trees_binary_search_tree.py::TestTree::test_add PASSED [ 78%]\ntests/frontendmasters/test_data_structures_trees_binary_search_tree.py::TestTree::test_create_correct_tree PASSED [ 80%]\ntests/frontendmasters/test_data_structures_trees_trie.py::TestSolution::test_create_trie PASSED [ 81%]\ntests/math_problems/test_find_numbers_with_even_number_of_digits.py::TestSolution::test_findNumbers PASSED [ 83%]\ntests/math_problems/test_fizz_buzz.py::TestSolution::test_fizzBuzz PASSED [ 84%]\ntests/math_problems/test_power_of_three.py::TestSolution::test_isPowerOfThree PASSED [ 85%]\ntests/math_problems/test_roman_to_integer.py::TestSolution::test_romanToInt PASSED [ 87%]\ntests/sorting_searching_problems/test_check_if_n_and_its_double_exist.py::TestSolution::test_checkIfExist PASSED [ 88%]\ntests/sorting_searching_problems/test_duplicate_zeros.py::TestSolution::test_duplicateZeros PASSED [ 90%]\ntests/sorting_searching_problems/test_merge_sorted_array.py::TestSolution::test_merge PASSED [ 91%]\ntests/sorting_searching_problems/test_valid_mountain_array.py::TestSolution::test_validMountainArray PASSED [ 92%]\ntests/string_problems/test_first_unique_character_in_a_string.py::TestSolution::test_firstUniqChar PASSED [ 94%]\ntests/string_problems/test_reverse_integer.py::TestSolution::test_reverse PASSED [ 95%]\ntests/string_problems/test_reverse_string.py::TestSolution::test_reverseString PASSED [ 97%]\ntests/string_problems/test_valid_anagram.py::TestSolution::test_isAnagram PASSED [ 98%]\ntests/string_problems/test_valid_palindrome.py::TestSolution::test_palindrom PASSED [100%]\n\n---------- coverage: platform linux, python 3.12.9-final-0 -----------\nName                                                                                  Stmts   Miss  Cover\n---------------------------------------------------------------------------------------------------------\nsrc/array_problems/best_time_to_buy_and_sell_stock_ll/solution.py                         9      0   100%\nsrc/array_problems/contains_duplicate/solution.py                                        21      0   100%\nsrc/array_problems/height_checker/solution.py                                            12      0   100%\nsrc/array_problems/intersection_of_two_arrays_ll/solution.py                             11      0   100%\nsrc/array_problems/max_consecutive_ones/solution.py                                      14      0   100%\nsrc/array_problems/move_zeroes/solution.py                                               28      1    96%\nsrc/array_problems/plus_one/solution.py                                                  14      0   100%\nsrc/array_problems/remove_duplicates_from_sorted_array/solution.py                       20      7    65%\nsrc/array_problems/remove_element/solution.py                                            18      0   100%\nsrc/array_problems/replace_elements_with_greatest_element_on_right_side/solution.py      10      0   100%\nsrc/array_problems/rotate_array/solution.py                                              14      0   100%\nsrc/array_problems/single_number/solution.py                                              9      0   100%\nsrc/array_problems/sort_array_by_parity/solution.py                                      11      0   100%\nsrc/array_problems/squares_of_a_sorted_array/solution.py                                  8      0   100%\nsrc/array_problems/two_sum/solution.py                                                   10      0   100%\nsrc/frontendmasters/algorithms/pathfinding/dijkstra/solution.py                          49      2    96%\nsrc/frontendmasters/algorithms/recursion/solution.py                                     15      1    93%\nsrc/frontendmasters/algorithms/searching/binary_search/solution.py                       30     12    60%\nsrc/frontendmasters/algorithms/searching/linear_search/solution.py                        7      0   100%\nsrc/frontendmasters/algorithms/sorting/bubble_sort/solution.py                           13      0   100%\nsrc/frontendmasters/algorithms/sorting/heap_sort/solution.py                             26      0   100%\nsrc/frontendmasters/algorithms/sorting/insertion_sort/solution.py                        12      0   100%\nsrc/frontendmasters/algorithms/sorting/merge_sort/solution.py                            22      0   100%\nsrc/frontendmasters/algorithms/sorting/quick_sort/solution.py                            20      0   100%\nsrc/frontendmasters/algorithms/sorting/radix_sort/solution.py                            29      0   100%\nsrc/frontendmasters/algorithms/tree_traversal/breadth_first/solution.py                  27      0   100%\nsrc/frontendmasters/algorithms/tree_traversal/depth_first/solution.py                    27      0   100%\nsrc/frontendmasters/data_structures/arrays/array_list/solution.py                        23      1    96%\nsrc/frontendmasters/data_structures/graphs/solution.py                                   22      0   100%\nsrc/frontendmasters/data_structures/linked_lists/singly_linked/solution.py               66     15    77%\nsrc/frontendmasters/data_structures/probabilistic/bloom_filter/solution.py               15      0   100%\nsrc/frontendmasters/data_structures/trees/avl_tree/solution.py                           95      8    92%\nsrc/frontendmasters/data_structures/trees/binary_search_tree/solution.py                 38      1    97%\nsrc/frontendmasters/data_structures/trees/trie/solution.py                               38      1    97%\nsrc/math_problems/find_numbers_with_even_number_of_digits/solution.py                    14      0   100%\nsrc/math_problems/fizz_buzz/solution.py                                                  16      0   100%\nsrc/math_problems/power_of_three/solution.py                                             10      1    90%\nsrc/math_problems/roman_to_integer/solution.py                                           12      0   100%\nsrc/sorting_searching_problems/check_if_n_and_its_double_exist/solution.py               16      2    88%\nsrc/sorting_searching_problems/duplicate_zeros/solution.py                               12      0   100%\nsrc/sorting_searching_problems/merge_sorted_array/solution.py                             7      0   100%\nsrc/sorting_searching_problems/valid_mountain_array/solution.py                          13      1    92%\nsrc/string_problems/first_unique_character_in_a_string/solution.py                        8      1    88%\nsrc/string_problems/reverse_integer/solution.py                                          13      1    92%\nsrc/string_problems/reverse_string/solution.py                                           15      0   100%\nsrc/string_problems/valid_anagram/solution.py                                            13      1    92%\nsrc/string_problems/valid_palindrome/solution.py                                         13      8    38%\n---------------------------------------------------------------------------------------------------------\nTOTAL                                                                                   945     64    93%\n\n\n============================== 71 passed in 0.68s ==============================\n</code></pre>"},{"location":"array_problems/best_time_to_buy_and_sell_stock_ll/","title":"122. Best time to buy and sell stock II","text":"<p>The objective of this task was the following:</p> <p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p> <p>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</p> <p>Firstly when I was looking at the problem, I was again overthinking the solution. I defined helper variables with the name <code>buy</code>, <code>sell</code>, <code>total</code> and <code>helper</code> each of them had their purpose which was <code>buy</code> was defined with the value 0, and I would add it up when I bought something on a given day. <code>Sell</code> was also added up when I sold something. <code>Total</code> was the difference between <code>Sell</code> and <code>Buy</code> and last but not least <code>helper</code> was defined to keep track to not sell something when nothing was bought.</p> <p>I am already making the solution more complex than it should be. In the next step I checked if the first value is 1 if yes I would buy it, so I set my <code>buy</code> variable to the value of <code>prices[p]</code> and set the <code>helper</code> variable to <code>1</code>, so that in the next iteration of the loop I would not buy. The next would be <code>if prices[p -1] &lt; prices[p] and helper == 1 and sell &gt; 0</code> which would be for the buy option, if the first element is not 1. As you can see this was much to complex and as well do not cover a lot of cases but, I was still going with this and trying to solve it which ended up in having more than 80 lines of code. At that moment I was solving one test case after another which was not the right was to go, so I started reading in the forum on how others approach this problem.</p> <p>There I read something like this:</p>  \ud83d\udca1 Since you can hold only 1 stock at a time. Just add up the differences between two consecutive days (if profitable).   <p>Before I trusted this sentence I did some calculations lets have a look: We start looking at the element on index 1 which is 1 and then look up the index before and see if our differences would be positive. 1 - 6 = -5 which is not profitable. Let's go to the next one. 3 - 1 = 2 this is a profitable day, so we save 2. 2 -3 = -1 which is not profitable. 4 -2 = 2 this is profitable, so we add 2 to our current 2 which = 4. Now we have 7 -4 which equals 3 which is again profitable and in total we have a profit of an amount of 7.</p> 6 1 3 2 4 7 <p>Now lets see if this is correct. The best buy would be at 1. After we would sell at 3 to make profit of 2. We would again buy at 2 and skip 4 to sell at 7 which would give us profit of 5. To add the profit which our first sell at 3 we would have a total profit of 7. So it is indeed the same profit as if we would just add up the differences for two consecutive days if profitable.</p> <p>So lets convert this logic into a step by step coding guideline on how to do it.</p> <ol> <li>First we need to define a variable which will save our profit. Moreover, a second variable is being created which stores the length of the prices array.</li> <li>In the next step we loop through it in a range of 1 and the length of the array</li> <li>Now in our if comparison we check if the element on our current index is greater than the index one before.</li> <li>If this is the case then we calculate the current index element minus the element on the index before to get the profitable difference and add it up to our profit</li> <li>Last but not least, just return the profit</li> </ol> <p>It really comes to understanding the problem and finding the most efficient solution to a given problem.</p> <p>The time complexity is O(n) since we only once go through the loop. The space complexity is O(1) since we save the value in our variable.</p>"},{"location":"array_problems/contains_duplicate/","title":"217. Contains Duplicate","text":"<p>The objective of this problem is following:</p> <p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p> <p>Example 1:</p> <pre><code>Input: nums = [1,2,3,1]\nOutput: true\n</code></pre> <p>Basically my approach was again a Big <code>O(n\u00b2)</code> which eventually at one test case got time exceeded. But I would still like to showcase on how I approach this problem.</p> <ol> <li>Since we have to check whether an array contains a duplicate value we would need to check it <code>n</code> times when <code>n</code> our length of an array is.</li> <li>So I create a variable with the length of the array minus one to get the actual length. A second variable <code>counter</code> which is the length of the array without the minus one.</li> <li>Now we want to check all items which each other, so I created a while loop which has the condition to run so long until my <code>counter</code> is greater or equal to 0. Inside the while loop I have a for loop and in this for loop I created a <code>temp</code> variable which is set to the last element of the array.</li> <li>Last but not least I created within the for loop an if condition which checks if the last item of the loop is equal to one of the others.</li> <li>When the for loop finish I subtract 1 from the index of my <code>temp</code> variable and 1 from my <code>counter</code></li> <li>With this approach I check every item with everyone and if a duplicate is found I return <code>True</code> otherwise <code>False</code></li> </ol> <p>With this approach I have a huge time complexity, but it is a solution.</p> <p>However, there is a solution which has only Big O of <code>O(n)</code> which would be linear time complexity. Let's have a look on that one.</p> <p>What is important is not to forget about the built-in methods which could help by solving the issue. In this particular use case we want to see duplicated items, so if the array would be sorted my next item would be the duplicate, if there is one.</p> <ol> <li>With the information above what we can do is we create again one variable called <code>length</code> and assign it the actual length of the array.</li> <li>Now we do <code>nums.sort()</code> and with this one we have a sorted array.</li> <li>In the next step we only need to loop through the array and in the if create a condition to check if my current item is equal to my next item and returning True or False</li> </ol> <p>Basically again every problem can be solved in different ways. Just don\u2019t forget to optimize your solution whenever possible but first make it work!</p>"},{"location":"array_problems/height_checker/","title":"1051. Height Checker","text":"<p>A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in\u00a0non-decreasing order\u00a0by height. Let this ordering be represented by the integer array\u00a0<code>expected</code>\u00a0where\u00a0<code>expected[i]</code>\u00a0is the expected height of the\u00a0<code>ith</code>\u00a0student in line.</p> <p>You are given an integer array\u00a0<code>heights</code>\u00a0representing the\u00a0current order\u00a0that the students are standing in. Each\u00a0<code>heights[i]</code>\u00a0is the height of the\u00a0<code>ith</code>\u00a0student in line (0-indexed).</p> <p>Return\u00a0the\u00a0number of indices\u00a0where <code>heights[i] != expected[i]</code>.</p> <p>Example 1:</p> <pre><code>Input: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation:\nheights:  [1,1,4,2,1,3]\nexpected: [1,1,1,2,3,4]\nIndices 2, 4, and 5 do not match.\n</code></pre> <p>Example 2:</p> <pre><code>Input: heights = [5,1,2,3,4]\nOutput: 5\nExplanation:\nheights:  [5,1,2,3,4]\nexpected: [1,2,3,4,5]\nAll indices do not match.\n</code></pre> <p>In this problem we need to check if the <code>array</code> which we get as an input is <code>sorted</code> and if not return the <code>count</code> of <code>elements</code> which are not in order. Let\u2019s have a look into my solution:</p> <ol> <li>I first initialize two variables which both are set to zero. One will be counting the elements in the array and the other are counting the elements which are not in order.</li> <li>In the next step I create a shallow copy of the current <code>heights</code> array so that I can sort the copied array. For this I used the <code>copy()</code> method which creates a shallow copy which saves memory since a new object is created which has references to the old one. Now I have an array called <code>sorted</code> , on this array I call the <code>sort()</code> method to have the array sorted.</li> <li>Now I create a <code>while</code> loop which runs so long until I went through all elements in the array.</li> <li>In the <code>body</code> of the <code>loop</code> I have an if statement which check whenever an element from the sorting array is not equal from the original array. If this is the case we add one to the <code>counter</code>. In the end we add up the <code>index</code> to check the next element.</li> <li>Last but not least we return the <code>counter</code> which tells me how many elements are not sorted in my original array.</li> </ol> <p>Big O</p> <ul> <li>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array.</li> <li>Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</li> </ul>"},{"location":"array_problems/intersection_of_two_arrays_ll/","title":"350. Intersection of Two Arrays II","text":"<p>Let's have a look on the description of the problem: Given two integer arrays <code>nums1</code> and <code>nums2</code>, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays, and you may return the result in any order.</p> <p>Example 1:</p> <pre><code>Input: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\n</code></pre> <p>My Solution is again Big O of <code>O(n\u00b2)</code> but as I mentioned earlier solved, is solved and optimizing comes later. Let's have a look on have I approached the problem.</p> <ol> <li>We need to create a new array which we return in the end with all the unique items.</li> <li>Next what I thought is that to have a list of unique items I need to check every item with everyone. So I create nested for loops, the first one loops through the first array and in that for loop I loop through the second one.</li> <li>Now I can compare every element from loop one with every item from loop two.</li> <li>In my second for loop I created an if condition which checks if the elements are the same and if they are here the most important part is. We add the element to the new array, delete it from the inner loop since it already is added and break the inner loop, so that the outer loop can take the next element.</li> </ol> <p>It is easy to read and to understand but not efficient if working with larger arrays.</p>"},{"location":"array_problems/max_consecutive_ones/","title":"485. Max Consecutive Ones","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given a binary array <code>nums</code>, return the maximum number of consecutive <code>1</code>'s in the array.</p> <p>Example 1:</p> <pre><code>Input: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n</code></pre> <p>This problem seems at first not that difficult since we could just loop through the array set a counter and add the counter up and set it to 0 if we have a 0, and this would work perfectly fine for the example above but what if we would have the reversed array? Our counter would be two and not three so here we need modify our approach to the problem a little bit. Let\u2019s have a look in a more detail into my solution:</p> <ol> <li>At first, I initialize one helper variable called counter and empty array. In counter variable I will add up whenever one appears in the array and set it again to zero if zero appears in the array. The array is needed to store the value of the counter when a zero occurs before setting it to zero themselves.</li> <li>Now we just <code>for loop</code> through the whole array to start the counting.</li> <li>In the <code>for loop</code> we create some conditions, first we check if our current element is one, if yes we count our counter plus one. However, when our current element is not one we add our current counter value to the array and in the next step we set the counter to zero.</li> <li>After the <code>for loop</code> we append again the counter to the array because it could be that the array only consist of one\u2019s, so it would only count up. In the next step we use the pythons built-in function <code>sort()</code> to have the biggest number at the last index in our array.</li> <li>In the end we return the last index of our array which is the number with the maximum of consecutive <code>1</code>'s in the array.</li> </ol> <p>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array. Space Complexity: <code>Big O(n)</code> . I use an additional array.</p>"},{"location":"array_problems/move_zeroes/","title":"283. Move Zeroes","text":"<p>Let's have a look on the description of the problem:</p> <p>Given an integer array <code>nums</code>, move all <code>0</code>'s to the end of it while maintaining the relative order of the non-zero elements.</p> <p>Note that you must do this in-place without making a copy of the array.</p> <p>Example 1:</p> <pre><code>Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n</code></pre> <p>My approach to the problem was following, since all the 0 need to be moved to the end, and we are not able to sort the array because we need to maintain the relative order what I did was delete all the 0 in the array, count how many times there was a 0 and then append it to the end <code>n</code> times.</p> <ol> <li>First of all I create a variable for the length of the array, a counter and a bool variable to keep track if there are multiple 0 in the beginning of the array.</li> <li>Now if the array is of length 1 or 0, just return it if not go to the while loop and in the while loop we set our condition to false since if there is any 0 in the array we can just stop, but if there is one we remove it, add to the counter 1 and set the bool variable to true again since it should start over. This happens <code>n</code> until all the 0 are deleted in the array.</li> <li>In the last step we create again a while loop and set the condition bigger than 0 so that we append <code>n</code> times our 0 to the array.</li> </ol> <p>In the end we have our array which has its relative order and all the zero elements in the end. The time complexity is Big O of <code>O(n\u00b2)</code> .</p>"},{"location":"array_problems/plus_one/","title":"66. Plus One","text":"<p>Let's have a look on the description of the problem:</p> <p>You are given a large integer represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least, significant in left-to-right order. The large integer does not contain any leading <code>0</code>'s.</p> <p>Increment the large integer by one and return the resulting array of digits.</p> <p>Example 1:</p> <pre><code>Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n</code></pre> <p>My Big O in this time is <code>O(n)</code> and the space complexity is constant since I am not using additional arrays. Let's have a look on how I approached this issue.</p> <ol> <li>Basically there are three main cases which are:</li> <li>My last item in the array is smaller than 9</li> <li>My last item in the array is 9 and the next one is smaller than 9</li> <li>My last item in the array is equal to 9 and the next one is 9.</li> <li>I started to implement the easiest case which is my last item is smaller than 9. So I started with creating a variable with the actual length of the array and then in an if condition to check if it's smaller than 9, if yes just add to the last item in the array one and return the array</li> <li>If this is not the case we need to loop through the array in a reversed order to start from the last item and in a range of the length of the array plus one to handle the edge case if there is only one item in the array.</li> <li>in the loop now I check if my item is smaller than one, if yes I just add to the next number plus one and return the array. If this is not the case I set the current item to 0 since. If my array consist only from nines I would have in the end only zeros and because of that I add after the loop at index 0 the number 1 and return the array.</li> </ol> <p>It is really important to think of all the cases which could happened and then implement one by one. In the end there is always time to make the code more readable or adjust it.</p>"},{"location":"array_problems/remove_duplicates_from_sorted_array/","title":"26. Remove Duplicates from Sorted Array","text":""},{"location":"array_problems/remove_duplicates_from_sorted_array/#remove-duplicates-from-sorted-array","title":"Remove Duplicates from Sorted Array","text":"<p>The objective of this Leetcode problem was to remove the duplicated values from the Array. The array is sorted so duplicated values would go one by another.</p> <p>My approach to this problem was the following:</p> <ol> <li>First I created a helper variable called \u201c<code>lastvalue</code>\u201d and assigned it to None</li> <li>In the next step I created an empty <code>array</code> where I would save the duplicated values in it. The reason why I would do this is that after I have all duplicated values in my empty array stored I could loop through it and call the remove method on my \u201c<code>nums array</code>\u201d to remove the duplicates.</li> <li>As next step I loop through the <code>Nums Array</code> and set the range to start with the index 1 (not 0) and go to the length of the array.</li> <li>After the loop I set an if condition which checks <code>if nums[n]</code> (my array on index n) is the same value <code>as my helper variable</code> \u201clastvalue\u201d <code>or if nums[0]</code> (on index 0) is the same as <code>nums[n]</code> to check if the first value of the list is the same as second.</li> <li>if the value is the same I append it to my empty array</li> <li>After the if condition is checked I update my lastvalue variable with the current value of the nums array, so I set it to <code>nums[n]</code></li> <li>Last but not least I loop through the helper array and call the <code>remove</code> function in the <code>nums</code> array to delete every element which is in the helper array.</li> <li>In the end I return the length of the <code>nums array</code> to get the value how many unique items are in there.</li> </ol> <p>This was my approach on how to tackle my \u201cfirst\u201d leetcode problem. In the end it took my quite a while until I got it correct, but I am happy that I could solve it without searching for help in the internet or using AI.</p> <p>Let's have a look on the Leetcode solution how they did it:</p> <p>There solution is quite easier and when I saw it first I had the feeling that I over-engineered or was thinking to complex but nevertheless, lets break down the leetcode solution to get a better understanding.</p> <ol> <li>They created to helper variables one is called \u201c<code>size</code>\u201d which has the value of the length of the nums array and the second variable is \u201c<code>insertIndex</code>\u201d which is set to 1.</li> <li>In the next step we create a loop where we loop through the nums array in the range of starting by 1 and the ending point would be the variable size, since this variable has the length of the array.</li> <li>Now the interesting part comes in: What they did is they created an if condition (<code>nums[i - 1] ! = nums[i]</code>) which is checking the value of <code>nums[i - 1]</code> which is the first value of the array because we started at 1 and arrays are indexed with 0 and <code>nums[i]</code> which is the first value according to our starting position from the range in the loop.</li> <li>If the condition is <code>True</code> we found a unique value, so we update our array on that position, we set the <code>nums[insertIndex] = nums[i]</code>. Afterward we increment the insertIndex by one since the list is order the next value can only be one higher.</li> <li>The last step is to return the <code>insertIndex</code> since this value will tell us how many unique items the array will have.</li> </ol> <p>As you can see the Leetcode solution is much shorter in steps and keeping it to the point. When I am looking at it, it seems obvious but when I sit down solving the problem I would probably never come up with this. In the end it comes to the point on how much do you practice daily and how much effort do you put into coding and understanding on what you do. With, time it will definitely get easier so keep on going.</p>"},{"location":"array_problems/remove_element/","title":"27. Remove Element","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> in-place. The order of the elements may be changed. Then return the number of elements in <code>nums</code> which are not equal to <code>val</code>.</p> <p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p> <ul> <li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li> <li>Return <code>k</code>.</li> </ul> <p>Example 1:</p> <pre><code>Input: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</code></pre> <p>In this problem we need to remove all the occurrences of an element in an array and return the new length of the array, but we have the constraint to not use an additional array since we need to do it in place. Let\u2019s have a look into my solution:</p> <ol> <li>I first create a variable named <code>counter</code> to store the count of a specific value provided as an argument to the function. This variable indicates the frequency of occurrence of the specified value within the array.</li> <li>Next I created a <code>while loop</code> which runs so long until our counter is greater than <code>0</code> . In this while loop we have another <code>for loop</code> to go through the elements in the array.</li> <li>Now we check if the current element of the array is equal to the value which is passed to the function. If yes we use the built-in python function <code>remove</code> to delete the element. Additionally, we subtract minus <code>1</code> to the counter.</li> <li>In the end, we return the updated length of the array by utilizing the <code>len</code> method directly on the array.</li> </ol> <p>Time Complexity: <code>Big O(n\u00b2)</code>, where <code>n</code> is the number of elements in the array. Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</p>"},{"location":"array_problems/replace_elements_with_greatest_element_on_right_side/","title":"1299. Replace Elements with Greatest Element on Right Side","text":"<p>Given an array\u00a0<code>arr</code>,\u00a0replace every element in that array with the greatest element among the elements to its\u00a0right, and replace the last element with\u00a0<code>-1</code>.</p> <p>After doing so, return the array.</p> <p>Example 1:</p> <pre><code>Input: arr = [17,18,5,4,6,1]\nOutput: [18,6,6,6,1,-1]\nExplanation:\n- index 0 --&gt; the greatest element to the right of index 0 is index 1 (18).\n- index 1 --&gt; the greatest element to the right of index 1 is index 4 (6).\n- index 2 --&gt; the greatest element to the right of index 2 is index 4 (6).\n- index 3 --&gt; the greatest element to the right of index 3 is index 4 (6).\n- index 4 --&gt; the greatest element to the right of index 4 is index 5 (1).\n- index 5 --&gt; there are no elements to the right of index 5, so we put -1.\n</code></pre> <p>Example 2:</p> <pre><code>Input: arr = [400]\nOutput: [-1]\nExplanation: There are no elements to the right of index 0.\n</code></pre> <p>When we're looking at this specific problem we can see that what we need to do it taking the first element of the <code>array</code>, excluding it from the <code>array</code> and then searching in the <code>array</code> for the <code>max</code> value of the items which are left. Now that we have the greatest element from index 1 until 5 we can set the greatest element to be our 0 element in the array. Now we do the same for the element two. We exclude the first element which we already set and as well the second one. Now we search for the greatest element between 2 and 5. We do this until our last element, since the last element has no neighbour we set it to <code>-1</code> . This solution would have a Big O of <code>O(n\u00b2)</code> which is not as suitable as we would like to. Let\u2019s have a look on a solution which do this differently:</p> <ol> <li>First we initialize two variables in our code. One will store the actual length of the array and the other one the right Maximum which is <code>-1</code> since our last element will be always <code>-1</code>.</li> <li>Now we loop through the array, but we start with the last item, go always one step back and end the loop when we are at the first item of the array.</li> <li>As a next step we create a new variable called new Maximum which uses the Math operation <code>Max</code> and takes the right Maximum which is currently <code>-1</code> and the current element of the array.</li> <li>After this step we can set our current element to the right Maximum because our last element in the array has no neighbour, so it has to be -1.</li> <li>Last but not least we set the right Maximum value to have the value of our new Maximum so that the next element has the correct <code>max</code>.</li> <li>Now we can return the in place modified array.</li> </ol> <p>Big O</p> <ul> <li>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array.</li> <li>Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</li> </ul>"},{"location":"array_problems/rotate_array/","title":"189. Rotate Array","text":"<p>The objective of this task was the following:</p> <p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p> <p>Example 1:</p> <pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</code></pre> <p>My first solution was to create a <code>while loop</code> and in this loop create another <code>for loop</code> to go through every element and move it <code>k</code> times. This would eventually work out but for large arrays the time complexity would rise significantly since my Big O in this Solution would be <code>O(n\u00b2)</code> and because of that my solution in Leetcode was not accepted because I got a timeout in one of the test cases. ****</p> <p>But still lets go step by step of what I did:</p> <ol> <li>I created two variables, <code>length</code> which is the length of the array and <code>k</code> which adjust <code>k</code> to be within the range of the array length.</li> <li>Now I create a <code>while loop</code> which checks if k is bigger than 0.</li> <li>Now I store my last element of the array in a variable called temp.</li> <li>In the next step I create a for loop which starts at the last element, stops when the index is 0 and goes backwards.</li> <li>In this loop I set my current element <code>nums[i]</code> to the last element <code>nums[i -1]</code> . For example since I go backwards and my last item is 7, and we consider a sorted array my new <code>nums[i]</code> is now 6. We stored the last element before because now we shifted the array by one element but our last element 7 is now gone.</li> <li>So after the loop finished we set <code>nums[0] to temp</code> which is 7. And in the last step we count k - 1 to do it k steps.</li> </ol> <p>So I didn't think about the spatial or time complexity in the beginning, but in the future I will do that. So here comes a solution which someone in the Leetcode community posted and its only 2 lines of code.</p> <pre><code>k = k % len(nums)\nnums[:] = nums[-k:] + nums[:-k]\n</code></pre> <p>This two lines solve the problem! Amazing, I was not thinking of slicing in the context of this problem. Let\u2019s have a deeper look into the solution.</p> <ol> <li>In the first line there is a <code>length</code> variable created which is called <code>k</code> and adjust <code>k</code> to be within the range of the array length.</li> <li>Starting with <code>nums[:]</code> these assigns the concatenated result back to the original array <code>nums</code>.</li> <li><code>nums[-k:]</code> this part slices the array from index <code>-k</code> which for example when <code>k</code> is 3 it would be the last three items in the array.</li> <li><code>nums[:-k]</code> this part slices the array from the beginning of the array until the index <code>-k</code> , excluding the end of the array. So for example the beginning would include 0, but it would exclude the last element. If we take a list with a length of 7 and our k is 3. It would take <code>nums[0]</code> <code>nums[1]</code> <code>nums[2]</code> <code>nums[3]</code> but not <code>nums[4]</code> . You can calculate <code>nums[:-k]</code> following, length - k and exclude the last element.</li> </ol>"},{"location":"array_problems/single_number/","title":"136. Single Number","text":"<p>Let's have a look on the description of the problem:</p> <p>Given a non-empty\u00a0array of integers <code>nums</code>, every element appears twice except for one. Find that single one. You must\u00a0implement a solution with a linear runtime complexity and use\u00a0only constant\u00a0extra space.</p> <p>Example 1:</p> <pre><code>Input: nums = [2,2,1]\nOutput: 1\n</code></pre> <p>Here again we can take the built-in functions from python as helping hands to solve the issue. What is important we can only use Big <code>O(n)</code> and use constant space which would be only one additional array.</p> <ol> <li>As, first we create a new array where we would store our unique values.</li> <li>Now we iterate through the array of nums.</li> <li>In the for loop we have an if condition which check if our first value from the list is not available in our unique values list. So the first item is not in our unique list since the list is empty, so we add it in there.</li> <li>Now we go with the next item, if this item is in our list we go to the else block and remove the item, so our list is again empty. We are doing this with every element in the nums array so eventually only the unique one will be left.</li> <li>In the end when the unique one is left we use pop() to return it.</li> </ol>"},{"location":"array_problems/sort_array_by_parity/","title":"905. Sort Array By Parity","text":"<p>Given an integer array\u00a0<code>nums</code>, move all the even integers at the beginning of the array followed by all the odd integers.</p> <p>Return\u00a0*any array\u00a0that satisfies this condition*.</p> <p>Example 1:</p> <pre><code>Input: nums = [3,1,2,4]\nOutput: [2,4,3,1]\nExplanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n</code></pre> <p>Example 2:</p> <pre><code>Input: nums = [0]\nOutput: [0]\n</code></pre> <p>In this problem we need to take all the even numbers and bring them in front of the array and the even to the back so that when someone is looking at the array there is a clear separation of elements visible. The easiest way to check if a number is even or odd is to check the remainder of it when doing modulo by two. Let\u2019s have a look at my solution:</p> <ol> <li>First I initialize two variables which will be my pointers. I use in this problem a <code>two pointer</code> solution. I call them <code>r</code> and <code>l</code> which stands for right and left.</li> <li>Now I do a <code>while loop</code> which is running so long until my right variable is smaller than the length of the array.</li> <li>In the body of the while loop I have a <code>if condition</code> which is checking the <code>r</code> element which is my current element of the array if the remainder of the <code>modulo</code> operation is <code>0</code>.</li> <li>If this is the case I switch the <code>l</code> element which is ensuring that the left side of the array has the even numbers with the <code>r</code> element which is going one by one through the array checking the elements which one is even and which one is odd.</li> <li>Now that the switch happened I increment the <code>l</code> variable by one since the switch happened, and I am sure of that my first element is an even number.</li> <li>After the <code>if condition</code> I increment the <code>r</code> variable by one.</li> <li>Last but not least we return the modified array.</li> </ol> <p>Big O</p> <ul> <li>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array.</li> <li>Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</li> </ul>"},{"location":"array_problems/squares_of_a_sorted_array/","title":"977. Squares of a Sorted Array","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given an integer array <code>nums</code> sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p> <p>Example 1:</p> <pre><code>Input: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n</code></pre> <p>There are multiple ways on how to tackle the following problem. It could be done without using additional space, or with to store the new values in an array. Let\u2019s have a look how I solved it:</p> <ol> <li>I created an additional array where I want to store the squares of each number.</li> <li>Now I use a <code>for loop</code> to loop through the elements in the array which is passed as an argument by the function.</li> <li>As a next step we multiply the element with itself and the result is being appended to the array which was created in the beginning.</li> <li>Last but not least we use the python built in <code>sort()</code> function to have the array sorted in non-decreasing order. In the end we return our array which we created in the beginning.</li> </ol> <p>This could be easily done without the additional space just replacing the current value with the result of the multiplication but for me this solution was cleaner.</p> <p>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array. Space Complexity: <code>Big O(n)</code> . I use an additional array.</p>"},{"location":"array_problems/two_sum/","title":"Two Sum","text":""},{"location":"array_problems/two_sum/#problem-description","title":"Problem Description","text":"<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p>"},{"location":"array_problems/two_sum/#solution-approach","title":"Solution Approach","text":"<p>We use a hash map to store previously seen numbers and their indices. For each number, we:</p> <ol> <li>Calculate the complement (target - current number)</li> <li>Check if the complement exists in our hash map</li> <li>If found, return both indices</li> <li>If not, add current number and index to hash map</li> </ol>"},{"location":"array_problems/two_sum/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul>"},{"location":"array_problems/two_sum/#code-implementation","title":"Code Implementation","text":"<pre><code>def two_sum(self, nums: List[int], target: int) -&gt; List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n</code></pre>"},{"location":"frontendmasters/algorithms/pathfinding/dijkstra/","title":"Dijkstra","text":""},{"location":"frontendmasters/algorithms/pathfinding/dijkstra/#pathfinding","title":"Pathfinding","text":"<p>Since we are aware of data structures like trees or graphs there is an interesting concept called Pathfinding. Let\u2019s imagine there is a Grid, and we have some coordinates from point A and some coordinates from point B. Now we need to find a way how A can reach B.</p> <pre><code>\u2022 \u2022 \u2022 \u2022 \u2022\n\u2022 A \u2022 \u2022 \u2022\n\u2022 \u2022 \u2022 \u2022 \u2022\n\u2022 \u2022 \u2022 \u2022 \u2022\n\u2022 \u2022 B \u2022 \u2022\n</code></pre> <p>Looking at the example above we would have many different option, we could go down from A until we reach the last row and then move right until we reach B. Another way would be to go one step to the right and then move down until we find B. Both of them would count as the shortest path to B.</p> <p>In the example above we do not have any constraints but what would happen if between A and B would be a wall?</p> <pre><code>\u2022 \u2022 \u2022 \u2022 \u2022\n\u2022 A \u2022 \u2022 \u2022\n\u2022 \u2022 \u2022 \u2022 \u2022\n\u2022 X X X X\n\u2022 \u2022 B \u2022 \u2022\n</code></pre> <p>Now our algorithm would not work anymore. Here, the basic idea of the Dijkstra algorithm comes in. In this algorithm, we start at both places\u2014the beginning and end node. We start \u201cspiraling\u201d outwards, marking each node with how far away it is from its original node.</p> <p>Below how it would look like after the first iteration at point A:</p> <pre><code>\u2022 1 \u2022 \u2022 \u2022\n1 A 1 \u2022 \u2022\n\u2022 1 \u2022 \u2022 \u2022\n\u2022 X X X X\n\u2022 \u2022 B \u2022 \u2022\n</code></pre> <p>Now we do the same but for point B:</p> <pre><code>\u2022 1 \u2022 \u2022 \u2022\n1 A 1 \u2022 \u2022\n\u2022 1 \u2022 \u2022 \u2022\n\u2022 X X X X\n\u2022 1 B 1 \u2022\n</code></pre> <p>We will do this exercise until we intersect with the two spirals. As soon as the spiral intersect we know we\u2019ve found the shortest possible path.</p> <pre><code>2 1 2 \u2022 \u2022\n1 A 1 \u2022 \u2022\n2 1 2 \u2022 \u2022\n\u2022 X X X X\n\u2022 1 B 1 \u2022\n\n2 1 2 \u2022 \u2022\n1 A 1 \u2022 \u2022\n2 1 2 \u2022 \u2022\n\u2022 X X X X\n2 1 B 1 2\n\n2 1 2 3 \u2022\n1 A 1 2 3\n2 1 2 3 \u2022\n3 X X X X\n2 1 B 1 2\n\n# We now intersect with B\n</code></pre>"},{"location":"frontendmasters/algorithms/recursion/","title":"Recursion","text":""},{"location":"frontendmasters/algorithms/recursion/#recursion","title":"Recursion","text":"<p>What recursion does is, it breaks large, difficult-to-solve problem s into multiple smaller problems and try to solve this first. In the end all the small solved problems are put together so that the big problem is being solved with the help of the smaller ones.</p> <p>In programming a recursive function is a function that calls itself.</p> <pre><code>def countTo(self, maximum, current):\n    if current &gt; max:\n        return\n    return countTo(maximum, current + 1)\n\nprint(countTo(5, 1))\n# this would print counting to 5 and starting from 1\n</code></pre> <p>As we see in the last example it's not that useful for counting since the above solution is more memory intensive than a for loop.</p> <p>But a use case for recursion would be fibonacci. A fibonacci number is the sum of the previous two fibonacci numbers. That being said <code>fibonacci(3)</code> is equal to <code>fibonacci(2) + fibonacci(1)</code>. To generalize this, <code>fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2)</code>. This is a recursively defined problem.</p> <p>The first question which we have to ask ourselves in recursion is what is the <code>base case</code>. The <code>base case</code> is when we stop recursion. If we don\u2019t define a <code>base case</code> we will most probably get a stack overflow when we run out of memory.</p> <p>Almost always with recursion your base case will be the first line of your recursive function. You need a good reason for that not to be the case.</p> <pre><code>def fibonacci(n):\n    # base case\n    if n == 2 or n == 1:\n        return 1\n    elif n &lt;= 0:\n        return 0\n    return fibonacci(n - 1) + fibonacci(n - 2)\n</code></pre> <p>What fibonacci is doing in the background is just adding 1 multiple times to each self. For fibonacci(6) for example we add up one, eight times because fibonacci(5) is 5 and fibonacci(4) is 3 so in total this is eight.</p> <p>The code itself is really elegant since its easy to read, but it is not really efficient since in a for loop this would be much faster, but again depending on the use case recursion can be more suitable than other solutions.</p>"},{"location":"frontendmasters/algorithms/searching/binary_search/","title":"Binary Search","text":""},{"location":"frontendmasters/algorithms/searching/binary_search/#binary-search","title":"Binary Search","text":"<p>Search is the act of looking for a particular element in an array. This ends up being really similar to sorting, just instead of doing a whole array, we're just looking for one element in an array.</p> <p>There are essentially two common ways of doing search: linear search and binary search. The former is the simplest code and really only useful if the list you're searching on is not sorted in any way. You just go through from 0 to the length of the array and ask \"is this the element I'm looking for?\" No frills here. Its complexity is <code>O(n)</code>.</p> <p>Binary search is a bit more interesting. It only works if the array is already sorted. For example, you search for 12, so you will go to the middle of the array which is 19 and start checking, is 12 bigger or equal to 19? No it's not bigger, so I need to go to the left side. So I do the next check, is 12 bigger or equal to 15? No it's not bigger I need to go more to the left side. Finally, we ask again is 12 bigger or equal to 12? Yes, now I have my element.</p> <p><code>[0, 5, 10, 12, 15, 19, 21, 22, 24, 30]</code></p>"},{"location":"frontendmasters/algorithms/searching/linear_search/","title":"Linear Search","text":""},{"location":"frontendmasters/algorithms/searching/linear_search/#todo","title":"TODO","text":""},{"location":"frontendmasters/algorithms/searching/two_crystal_balls/","title":"Two crystal balls","text":""},{"location":"frontendmasters/algorithms/searching/two_crystal_balls/#todo","title":"TODO","text":""},{"location":"frontendmasters/algorithms/sorting/bubble_sort/","title":"Bubble Sort","text":""},{"location":"frontendmasters/algorithms/sorting/bubble_sort/#bubble-sort","title":"Bubble Sort","text":"<p>The algorithm is pretty simple: compare two items in an array that are next to each other. If they're out of order (that is, the larger one comes first in the array) swap them. Then move forward one index, compare again, swap if needed, and continue to the next item in the array. Once we've reached the end of the array, if we've swapped anything in the previous run through, the array could still be out of order, so we have to pass through again. Once we run through the whole array with no swaps, the array is sorted!</p> 1 5 4 2 3 <p>Bubble Sort will start comparing 1 with 5, if 1 is bigger than 5. This is not the same, so we leave 1 at the index it is currently. Now we go with 5 and compare it with 4, this time 5 is bigger than 4, so we switch 4 and 5. In the next step we look at 5 which swapped places with 4 and look if 5 is bigger than 2, this is the case, so we again swap 5, and we do this until the end of the array. Because when 5 is on the last index of our array we still need to sort the other elements so bubble sort will again go from beginning to end so that the array is fully sorted.</p> <ol> <li>1 &gt; 5 = False</li> <li>5 &gt; 4 = True</li> <li>5 &gt; 2 = True</li> <li>5 &gt; 3 = True</li> </ol> <p>After the first bubble sort our array would look like this:</p> 1 4 2 3 5 <ol> <li>1 &gt; 4 = False</li> <li>4 &gt; 2 = True</li> <li>4 &gt; 3 = True</li> <li>4 &gt; 5 = False</li> </ol> <p>And after the second iteration we have our sorted array.</p> 1 2 3 4 5"},{"location":"frontendmasters/algorithms/sorting/heap_sort/","title":"Heap Sort","text":""},{"location":"frontendmasters/algorithms/sorting/heap_sort/#heap-sort","title":"Heap Sort","text":"<p>A heap is an array that represents a tree data structure and has to be sorted in a particular way to represent that tree. Priority queues are often represented as heaps and often those two terms are used interchangeably even if the priority queue is implemented a different way.</p> <p>To explain a priority queue, we can think of internet traffic and how it handles data packets. For example, if we are watching Netflix in one browser tab and in another tab, we have Google Drive where we are uploading something or syncing to our local machine, it would prioritize the Netflix tab. The reason for this is that when we watch something, we do not want the stream to lag or to be in a loading state. On the other hand, the upload or sync can lose some packets since we do not need it synced or uploaded immediately. This is an example of a priority queue, and these are usually stored as heaps.</p> <p>In our example we will talk about binary heaps but keep in mind there are other as well. A binary heap is an array, in comparison to a BST which is made up of node objects. In a BST there is a strict order where a left child is which is not true for binary heap. Binary heap guarantee that the parent is always greater than the children but there is no guarantees between sibling nodes.</p> <p>The process of heapsort is following:</p> <ol> <li>Make the array a max heap and for that, you\u2019ll run the heapify on the first half of the array, going backwards.</li> <li>Loop over the array / max array, dequeuing the root node, which will give the largest item. Now we swap the root node with the last item in the array to ensure that our last item is now the biggest in the array.</li> <li>After dequeing each item, the heapify function will be run to find the next root node</li> <li>In the next loop we will dequeue the new root node and swap it with the second to last item in the array and run heapify again.</li> <li>We are finished when there are no items to dequeue and the array is sorted.</li> </ol> <p>Big O</p> <ul> <li>Time Complexity: <code>Big O(n log (n))</code>, where <code>n</code> is the number of elements in the array.</li> </ul>"},{"location":"frontendmasters/algorithms/sorting/insertion_sort/","title":"Insertion Sort","text":""},{"location":"frontendmasters/algorithms/sorting/insertion_sort/#insertion-sort","title":"Insertion Sort","text":"<p>At insertion sort we take our first element of our array as sorted which means everything after the first element is unsorted. This means that we start our comparison with the element on index one.</p> <p>This works somehow like bubble sort just reversed. We take our element on index one and check if the element is lager than on index zero. If our element on index 1 is not larger we move it to the right, and we have a new first element and a new second element since they both switched.</p> <p>In the next step we do the same but with the element on index two we check if the element on index two is larger than the element on index one. If our element on index 2 is lager then on index 1 we do nothing since they are on the correct position, so we go with the next one.</p> 3 2 5 4 1 <ol> <li>Is arr[1] larger than arr[0]? No, switch the places</li> </ol> 2 3 5 4 1 <ol> <li>Is arr[2] larger than arr[1]? Yes, do nothing</li> </ol> 2 3 5 4 1 <ol> <li>Is arr[3] larger than arr[2]? No, switch places</li> <li>Is arr[2] (swapped) larger than arr[1]? Yes, do nothing</li> </ol> 2 3 4 5 1 <ol> <li>Is arr[4] larger than arr[3]? No, switch places</li> <li>Is arr[3] (swapped) larger than arr[2]? No, switch places</li> <li>Is arr[2] (swapped) larger than arr[1]? No switch places</li> <li>Is arr[1] (swapped) larger than arr[0]? No switch places</li> </ol> <p>End of list, list is sorted</p> 1 2 3 4 5"},{"location":"frontendmasters/algorithms/sorting/merge_sort/","title":"Merge Sort","text":""},{"location":"frontendmasters/algorithms/sorting/merge_sort/#merge-sort","title":"Merge Sort","text":"<p>Merge Sort by definition takes the array which needs to be sorted break it down into smaller arrays so long until the length of the array is 1 or 0. It is doing this because an array of length 1 or 0 is sorted by definition since there is only one or zero elements in there. In the next step Merge Sort is taking this arrays of length 1 or 0 and is combining it together but here it checks is the first element (the only element) bigger then the other element from the other array. If its smaller it appends it to the front, if its bigger it will append it to the end.</p> <p>In merge sort we need <code>two functions</code> . The first breaks down the array into smaller arrays (which is our recursive function) and the other is a function that takes two <code>sorted</code> arrays and returns back one sorted array.</p> <p>In the example above you can see an unsorted array split into arrays of length 1 or 0. Afterward our merge function combine this arrays and checking weather the one and only element is bigger than the other one. In the end we get the sorted array.</p> <p>In merge sort the <code>best case / worst case / average case</code> have the same <code>Big O</code>, since no matter how sorted the array is, it will split it up into arrays of length one or zero and then combine it back together. Since every item in the array has to be looked at least once we are going to have <code>Big O(n)</code> .</p> <p>Since not every item needs to be checked with every other item in the arrays, for example we have <code>[1, 2]</code> and <code>[4, 7]</code> , 7 will be not compared with 1 or 2 because since 4 is bigger than 1 and 2 and the list is already sorted it will be appended to the end of the arrays after 4. So with more items in the array our <code>Big O</code> will change eventually to be <code>log n</code>.</p> <p>So we combine now the both scenarios and have the Big O for merge sort which is <code>O(n log n)</code> .</p> <p>For the space complexity since we create for every item an array our Big O is <code>O(n)</code></p>"},{"location":"frontendmasters/algorithms/sorting/quick_sort/","title":"Quick Sort","text":""},{"location":"frontendmasters/algorithms/sorting/quick_sort/#merge-sort","title":"Merge Sort","text":"<p>Merge Sort by definition takes the array which needs to be sorted break it down into smaller arrays so long until the length of the array is 1 or 0. It is doing this because an array of length 1 or 0 is sorted by definition since there is only one or zero elements in there. In the next step Merge Sort is taking this arrays of length 1 or 0 and is combining it together but here it checks is the first element (the only element) bigger then the other element from the other array. If its smaller it appends it to the front, if its bigger it will append it to the end.</p> <p>In merge sort we need <code>two functions</code> . The first breaks down the array into smaller arrays (which is our recursive function) and the other is a function that takes two <code>sorted</code> arrays and returns back one sorted array.</p> <p>In the example above you can see an unsorted array split into arrays of length 1 or 0. Afterward our merge function combine this arrays and checking weather the one and only element is bigger than the other one. In the end we get the sorted array.</p> <p>In merge sort the <code>best case / worst case / average case</code> have the same <code>Big O</code>, since no matter how sorted the array is, it will split it up into arrays of length one or zero and then combine it back together. Since every item in the array has to be looked at least once we are going to have <code>Big O(n)</code> .</p> <p>Since not every item needs to be checked with every other item in the arrays, for example we have <code>[1, 2]</code> and <code>[4, 7]</code> , 7 will be not compared with 1 or 2 because since 4 is bigger than 1 and 2 and the list is already sorted it will be appended to the end of the arrays after 4. So with more items in the array our <code>Big O</code> will change eventually to be <code>log n</code>.</p> <p>So we combine now the both scenarios and have the Big O for merge sort which is <code>O(n log n)</code> .</p> <p>For the space complexity since we create for every item an array our Big O is <code>O(n)</code></p>"},{"location":"frontendmasters/algorithms/sorting/radix_sort/","title":"Radix sort","text":""},{"location":"frontendmasters/algorithms/sorting/radix_sort/#radix-sort","title":"Radix Sort","text":"<p>Radix sort is a non-comparison based sorting.</p> <p>We're going to sort the ones place first, so all the numbers in the ones place are in order from 0 to 9. We will create ten buckets, one for each integer zero to nine. Then we'll loop <code>d</code> times when <code>d</code> is the maximum length of a number in our array. So if the longest number in our array is 90932 then <code>d</code> would be 5. Then in the inner loop we would enqueue all the numbers in the buckets based on what digit we were sorting and then dequeue them back into the main array.</p> <p>Big O here is different from in the other search algorithms since you are dependent on another <code>variable</code> which is d in our example and that is the maximum length of a number.</p> <p>The more buckets we need, the larger the complexity. So instead of being O(n\u00b2) or O(n _ n), it ends up being O(n _ k). So is it better or worse than O(n log n) sorts? It depends! If you have a lot of numbers with lots of varied lengths that will bucket into a good distribution it can be very effective. If you number [1, 10, 100, 1000, 10000, 100000] etc. it ends up being the worst sort. It ends up being O(n\u00b2) at that point.</p> <p>What about the spatial complexity? It ends up being O(n + k) and this why radix sort is really only used in very specific circumstances: it's not great in terms of how much space it takes.</p>"},{"location":"frontendmasters/algorithms/tree_traversal/breadth_first/","title":"Breadth first","text":""},{"location":"frontendmasters/algorithms/tree_traversal/breadth_first/#breadth-first-tree-traversals","title":"Breadth-First Tree Traversals","text":"<p>There is another mechanism to traverse a tree, which is breadth-first traversal. This process is not recursive, its iterative since we do not go into depth first here we go one layer at a time. We start at the root and go slowly down one by one to the end of the tree.</p> <p>In the end to achieve the breadth first traversals we use a queue. A queue is an array that the first thing you into is the first thing you get out of it. It works like a FIFO, first in first out, the opposite would be a stack which is first in last out, FILO.</p> <p>The process behind this is the following, we add the root node to the queue, next we add the left child to the queue, next the right child to the queue. After that, we\u2019ll just dequeue an item off the queue. This we do until there is no item left in the queue.</p> <pre><code>-&gt; start function by adding root to the queue, queue = [8]\n-&gt; process 8, add to final array array = [8]\n-&gt; queue 3 and 10 to queue, queue = [3, 10]\n-&gt; dequeue 3, queue = [10]\n-&gt; queue 3's children, queue = [10, 1]\n-&gt; add 3 to final array, array = [8, 3]\n-&gt; dequeue 10, queue = [1]\n-&gt; queue 10's children, queue = [1]\n-&gt; add 10 to final array, array = [8, 3, 10]\n-&gt; dequeue 1, queue = []\n-&gt; queue 1's children, nothing\n\nfinal array is [8, 3, 10, 1]\n</code></pre>"},{"location":"frontendmasters/algorithms/tree_traversal/depth_first/","title":"Depth first","text":""},{"location":"frontendmasters/algorithms/tree_traversal/depth_first/#depth-first-tree-traversals","title":"Depth First Tree Traversals","text":"<p>Traversals are needed when you serialize the entire tree into a flat data structure. For example, we have a valid BST, and we would like to get all the node values into an array. There would be three variations of depth-first traversal how you could achieve it.</p> <ul> <li>pre-order traversal</li> <li>This process the node starting from the root node going to the left subtree and then to the right subtree.</li> <li>inorder traversal</li> <li>This process the node starting from the left subtree going to the root node and then to the right subtree.</li> <li>postorder traversal</li> <li>This process the node starting from the left subtree but with going forward with all the nodes first which do not have a child. After that it will go to the right subtree first to the nodes without child and in the end the root node.</li> </ul> <p>All of them have their own use case. Preorder traversal is useful when you want to make a deep copy of a tree, since you do copy a node and then add its left child and then its right tree. If you have a BST you do want to use inorder. Postorder traversal use case is when you want to delete the tree since it would go from the left childs to the right ones and in the end go to the root node.</p>"},{"location":"frontendmasters/data_structures/arrays/array_list/","title":"Array List","text":""},{"location":"frontendmasters/data_structures/arrays/array_list/#arraylist","title":"ArrayList","text":"<p>If we would not have arrays and only object, how we would need to implement a class to create arrays, call the methods like adding numbers, getting a number, deleting etc.</p> <p>For array list, this works more or less how we as humans tend think about it: in memory we'll lay out everything sequentially in memory. Just by knowing where the start of the array is and the index, we know where the thing we're looking for in memory. This would be a O(1) in terms of complexity. No matter how big the ArrayList is, array lookups take the same amount of time.</p> <p>Now imagine our list is 15,000 items long, and we delete the 1 index. We now have to shift 14,998 items over in memory. This is called compacting, and it's painful for ArrayList. Same applies for inserts.</p>"},{"location":"frontendmasters/data_structures/graphs/","title":"Graphs","text":""},{"location":"frontendmasters/data_structures/graphs/#graphs","title":"Graphs","text":"<p>Graphs are a datastructure that is extremely useful, but you may not use it in your code daily. They are all about modeling relations between many items. In comparison to trees, here we do not have a structure with left and right subtrees. In Graphs the connections are one to many or many to many or even one to one. An example would be Facebook. In Facebook each person would be a node which could be compared to and SQL row in a database. Next we would have \u201cfriendships\u201d between nodes which are edges. The edge would represent the connection between the two nodes. In Facebook the connection is bidirectional since one sends the friendship request and the other one have to approve or accept it. In X or former Twitter we have unidirectional edges since there someone can just follow me and I do not need to follow back or approve it per default.</p> <p>Let\u2019s have a look on a basic graph and use an algorithm to find the most common job title amongst the people I follow:</p> <pre><code>   Peter \u2014 Dan\n  /    \\\nme    Aleks\n  \\    /\n   Eva\n-&gt; Add me to queue\n-&gt; Dequeue me\n-&gt; Add my job to the tally (devops)\n-&gt; Queue my connections, Peter and Eva\n-&gt; Dequeue Peter\n-&gt; Add Peter's job to the tally (frontend)\n-&gt; Queue Peter's connection, Dan and Aleks\n-&gt; Dequeue Eva\n-&gt; Add Eva's job to the tally (architekt)\n-&gt; Queue Eva'S connections. Aleks has already been queued so don't add any.\n\n-&gt; Finish first iteration, one degree of separation\n</code></pre> <p>So traversing algorithm fits best here? We're analyzing everything in a limited depth of a sub-tree and breadth-first is well-equipped to do that. Instead of letting breadth-first traversal run to completion, we'll just limit how many times that outer loop runs, effectively limiting how many levels down it goes, or how many degrees of separation!</p>"},{"location":"frontendmasters/data_structures/linked_lists/singly_linked/","title":"Singly linked","text":""},{"location":"frontendmasters/data_structures/linked_lists/singly_linked/#linkedlist","title":"LinkedList","text":"<p>For our second data structure, we're going to implement a LinkedList. LinkedList is made of a bunch of nodes that point to the next one in the list. Every node in a LinkedLists has two properties, the value of whatever is being store and a pointer to the next node in the list. These nodes will not be sequential in memory, meaning we don't get the easy lookups but the advantage is that adding things is easy since we don't have to do the compacting we had to do with ArrayList.</p> <p>So let's talk about look-ups. You only have access to a head node. The head node will point to the 1 node. The 1 node points to the 2 node, etc. If we want to lookup index 10,000 we're going to have to make 10,000 jumps. That means the lookups grow with length and therefore the Big O is O(n) for lookups.</p> <p>Let's chat about where LinkedLists are useful then. What do we need to do if we want to delete index 10? We'll first do a lookup node 9, and we'll change the pointer of node 9's to point at node 11. Done! So these deletions are O(1).</p>"},{"location":"frontendmasters/data_structures/probabilistic/bloom_filter/","title":"Bloom Filter","text":""},{"location":"frontendmasters/data_structures/probabilistic/bloom_filter/#bloom-filters","title":"Bloom Filters","text":"<p>Bloom filters are an interesting data structure which are designed to tell you quickly and efficiently if an item is in a set. The trade-off which they are taken is following, they can\u2019t tell you for sure if an item is in the set, but they can definitely tell you that an item is not part of the set. Stated differently, bloom filters have a false positive rate but do not have false negatives.</p> <p>The website Medium is using the data structure of bloom filters in a way that after you read an article on their website you will get three recommendations below, which are for sure articles which you have never read before.</p>"},{"location":"frontendmasters/data_structures/trees/avl_tree/","title":"Avl Tree","text":""},{"location":"frontendmasters/data_structures/trees/avl_tree/#self-balancing-avl-tree","title":"Self Balancing AVL Tree","text":"<p>AVL Trees solve an issue which Binary Search Trees are having. BST can get easily out of balance and AVL Trees tackle this issue to self balance the tree. The name AVL comes from its authors Georgy Adelson-Velsky and Evgenii Landis.</p> <p>AVLs are specialized BSTs, which means that a valid AVL tree is always a BST, but not necessary the other way around. The main difference between this two is following, adding the item is literally the same in both cases, what is different is the way back, so the recursive calls to check if the node is balanced after you added the new node. A tree is out of balance when its subtree difference of heights is greater than one. The benefit of this is that we can ensure that our worst case scenario is not <code>O(n)</code> but it becomes <code>O(log n)</code> .</p> <p>Let\u2019s assume we have the following AVL tree:</p> <pre><code>  5\n\n    \\\n\n      8\n</code></pre> <p>The above is a valid AVL tree and now we would like to add the node 9 to it.</p> <pre><code>   5 - node A\n\n    \\\n\n      8 - node B\n\n       \\\n\n         9 - node C\n</code></pre> <p>On the way up from the recursion we check the following:</p> <p>\u2014&gt; check balance of node C: left height is 0, right height is 0, balanced</p> <p>\u2014&gt; check balance of node B: left height is 0, right height is 1, balanced</p> <p>\u2014&gt; check balance of node A: left height is 0, right height is 2, unbalanced, right heavy, child is right heavy</p> <p>As we can see our tree is unbalanced so we need to perform a right rotation. Now we swap the values of nodes A and B. We make node B the left child of node A and make node C the right child of node A.</p> <p>In the end we get the following AVL tree:</p> <pre><code>        8 - node A\n\n    /       \\\n\n  5           9\n node B       node C\n</code></pre>"},{"location":"frontendmasters/data_structures/trees/binary_search_tree/","title":"Binary search Tree","text":""},{"location":"frontendmasters/data_structures/trees/binary_search_tree/#binary-search","title":"Binary Search","text":"<p>Search is the act of looking for a particular element in an array. This ends up being really similar to sorting, just instead of doing a whole array, we're just looking for one element in an array.</p> <p>There are essentially two common ways of doing search: linear search and binary search. The former is the simplest code and really only useful if the list you're searching on is not sorted in any way. You just go through from 0 to the length of the array and ask \"is this the element I'm looking for?\" No frills here. Its complexity is <code>O(n)</code>.</p> <p>Binary search is a bit more interesting. It only works if the array is already sorted. For example, you search for 12, so you will go to the middle of the array which is 19 and start checking, is 12 bigger or equal to 19? No it's not bigger, so I need to go to the left side. So I do the next check, is 12 bigger or equal to 15? No it's not bigger I need to go more to the left side. Finally, we ask again is 12 bigger or equal to 12? Yes, now I have my element.</p> <p><code>[0, 5, 10, 12, 15, 19, 21, 22, 24, 30]</code></p>"},{"location":"frontendmasters/data_structures/trees/trie/","title":"Trie","text":""},{"location":"frontendmasters/data_structures/trees/trie/#tries","title":"Tries","text":"<p>Trie is a specific tree data structure which is optimized for searching by prefix. The most common example which everyone is familiar is autocompletion. A trie starts with a root node that doesn\u2019t represent anything. Often it is just an empty string.</p> <p>It has a bunch of child nodes (as many are necessary) that represent one letter, the first letter of all the words added to the data structure. Each of those letter-nodes will have children nodes for all the\u00a0second\u00a0letters of the words that are represented in the data structure. So on and so forth, there will be a chain of nodes that represent each letter in the data structure.</p> <p>Below an example of how this data structure looks like:</p> <pre><code>  a \u2013 [various children]\n /\nb \u2013 o \u2013 s \u2013 t \u2013 o \u2013 n\n     \\\n      i \u2013 s \u2013 e\n</code></pre> <p>So based on this, you'd get suggestions of \"Boston\" and \"Boise\".</p> <p>Since some words are contained within chains of others (for example, there are two separate cities, one called \"Salina\" and one called \"Salinas\" or \"Sandy\" and \"Sandy Springs\".) You'll often have a flag in there that signifies the node you're on is a complete word, so you can just add it to the list and then keep going on the children.</p>"},{"location":"math_problems/find_numbers_with_even_number_of_digits/","title":"1295. Find Numbers with Even Number of Digits","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given an array <code>nums</code> of integers, return how many of them contain an even number of digits.</p> <p>Example 1:</p> <pre><code>Input: nums = [12,345,2,6,7896]\nOutput: 2\nExplanation:\n12 contains 2 digits (even number of digits).\n345 contains 3 digits (odd number of digits).\n2 contains 1 digit (odd number of digits).\n6 contains 1 digit (odd number of digits).\n7896 contains 4 digits (even number of digits).\nTherefore only 12 and 7896 contain an even number of digits.\n</code></pre> <p>In this problem we had to use our math skills since this required some knowledge on how to get one by one every digit of a number. Let\u2019s have a look on my solution:</p> <ol> <li>First I initialize two variables, one called digits which I set to <code>0</code> and the next one counter which I also set to <code>0</code>.</li> <li>Now I <code>for loop</code> through the array which is passed into the function. Now in the for loop I create a <code>while loop</code> with the condition to run so long until x which is my current element from the array, is bigger than 0.</li> <li>Next I divide my current element <code>x</code> with <code>10</code> and use the <code>math.floor</code> function the round it down. Additionally, after the calculation we add one to our digits variable since it our element x has at least one digit.</li> <li>As a next step we take the digits variable and set up an if condition which checks <code>if digits modulo two equals 0</code> . If this is the case we would add <code>1</code> to the counter. After we are done with the first element of <code>x</code> we set the digits variable to <code>0</code> to again count it for the next element.</li> <li>In the end we <code>return</code> the <code>counter</code> which tells us how many numbers in the array have an even digit count.</li> </ol> <p>Time Complexity: <code>Big O(n\u00b2)</code>, where <code>n</code> is the number of elements in the array. Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</p>"},{"location":"math_problems/fizz_buzz/","title":"412. Fizz Buzz","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given an integer\u00a0<code>n</code>, return\u00a0a string array <code>answer</code> (1-indexed) where:</p> <ul> <li><code>answer[i] == \"FizzBuzz\"</code>\u00a0if\u00a0<code>i</code>\u00a0is divisible by\u00a0<code>3</code>\u00a0and\u00a0<code>5</code>.</li> <li><code>answer[i] == \"Fizz\"</code>\u00a0if\u00a0<code>i</code>\u00a0is divisible by\u00a0<code>3</code>.</li> <li><code>answer[i] == \"Buzz\"</code>\u00a0if\u00a0<code>i</code>\u00a0is divisible by\u00a0<code>5</code>.</li> <li><code>answer[i] == i</code>\u00a0(as a string) if none of the above conditions are true.</li> </ul> <p>Example 1:</p> <pre><code>Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\n</code></pre> <p>In this problem we get already hints in the description, one of the hints is that we need multiple if statements to check the different conditions. To check all of these conditions we need to loop through the integer <code>n</code> or loop so long as the integer <code>n</code> is. Let\u2019s have a more detailed look on my solution:</p> <ol> <li>First I created a new array where I would store my response. Additionally, I created a helper variable counter which I set to one, since we start with one.</li> <li>In the next step I created a <code>while loop</code> with the condition to run as long as my counter is less than equal then my <code>n</code> .</li> <li>Now we write our if statements which checks the different cases when to append \u201cFizzBuzz\u201d, \u201cFizz\u201d, \u201cBuzz\u201d or the counter as <code>string</code> in our results list.</li> <li>After all the if conditions are done we add one to our counter to check the next number. After the <code>while loop</code> finished we return our results list.</li> </ol> <p>The time complexity of my solution is <code>Big O(n)</code> since we loop so long until our n value and for the space complexity of my solution is as well <code>Big O(n)</code> since we created an additional array to append the result of the calculations.</p>"},{"location":"math_problems/power_of_three/","title":"326. Power of Three","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given an integer\u00a0<code>n</code>, return\u00a0<code>true</code>\u00a0if it is a power of three. Otherwise, return\u00a0<code>false</code>.</p> <p>An integer\u00a0<code>n</code>\u00a0is a power of three, if there exists an integer\u00a0<code>x</code>\u00a0such that\u00a0<code>n == 3x</code>.</p> <p>Example 1:</p> <pre><code>Input: n = 27\nOutput: true\nExplanation: 27 = 33\n</code></pre> <p>I approached the problem with the thought that if <code>n</code> is a power of three integer, then by counting up all the powers of three, I would eventually reach the desired number. Let\u2019s have a more detailed look on my solution:</p> <ol> <li>I start by initializing two helper variables, both set to zero. One variable will store the result from the power of three calculation, while the other will count up to determine the next power of three.</li> <li>Next, I create a <code>while loop</code> with the condition to run until my helper variable result is less than or equal to the parameter given to the function.</li> <li>Within the loop, we use the <code>pow</code> function from the math module to traverse the power of three sequence. We stop when our sequence value exceeds the value passed to the function.</li> <li>If our power of three result matches the passed value, we terminate the loop and <code>return True</code>. Otherwise, we increment our helper variable 'count' by one, and eventually, the loop stops, <code>returning False</code> since the passed value is not in the power of three sequence.</li> </ol>  \ud83d\udca1 Time complexity :\u00a0`O(log\u2061b(n))`. In my case that is\u00a0`O(log\u20613n)`. The number of divisions is given by that logarithm. Space complexity :\u00a0`O(1)`. We are not using any additional memory."},{"location":"math_problems/roman_to_integer/","title":"13. Roman to Integer","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Roman numerals are represented by seven different symbols:\u00a0<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p> <pre><code>SymbolValue\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n</code></pre> <p>For example,\u00a0<code>2</code> is written as <code>II</code>\u00a0in Roman numeral, just two ones added together. <code>12</code> is written as\u00a0<code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p> <p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p> <ul> <li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.</li> <li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.</li> <li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li> </ul> <p>Given a roman numeral, convert it to an integer.</p> <p>Example 1:</p> <pre><code>Input: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n</code></pre> <p>This problem seems at first glance really easy to achieve but the constraint with the subtractions make it more difficult than expected for me. Let\u2019s have a look into my solution:</p> <ol> <li>First we need to create a dict where we map the roman character to the actual value. Moreover, we create two helper variables, one for the total value and one to keep track of the length of our string.</li> <li>Next we create a <code>while loop</code> with the condition to run so long until our helper variable is bigger then the length of the string.</li> <li>In the <code>while loop</code> we need to check if our first element is smaller than the next one if this is the case we know that we need to subtract the next item with the current one and add the sum to our helper variable. After adding it to our total helper variable we need to add two to our helper variable which keeps track of the length of the string.</li> <li>In the other case we just add the current index item to our total helper variable and after it, we add one to our helper variable which keeps track of the length of the string. In the end we return the total sum as an integer.</li> </ol> <p>As there is a finite set of roman numerals, the maximum number possible number can be\u00a0<code>3999</code>, which in roman numerals is\u00a0<code>MMMCMXCIX</code>. As such the time complexity is\u00a0*<code>O*(1)</code></p> <p>Because only a constant number of single-value variables are used, the space complexity is\u00a0*<code>O*(1)</code>.</p>"},{"location":"sorting_searching_problems/check_if_n_and_its_double_exist/","title":"1346. Check If N and Its Double Exist","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given an array <code>arr</code> of integers, check if there exist two indices <code>i</code> and <code>j</code> such that :</p> <ul> <li><code>i != j</code></li> <li><code>0 &lt;= i, j &lt; arr.length</code></li> <li><code>arr[i] == 2 * arr[j]</code></li> </ul> <p>Example 1:</p> <pre><code>Input: arr = [10,2,5,3]\nOutput: true\nExplanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]\n</code></pre> <p>In this problem there is an edge case which you probably faced but depending on your solution it could also be that your implementation already covered it. For me, it was not the case, so let's have a more detailed look into my solution:</p> <ol> <li>I created two variables, one named counter which I set to zero, and the other one I called length which has the value the length of the array.</li> <li>Now I create another variable called count and here I use the <code>python package collections</code> to use the function <code>Counter</code>. The function is counting the occurrences of a value in an array and store it as a <code>key value hashmap</code>. I used it for the edge case which is <code>0</code>. Later on I will explain why.</li> <li>Now before I create any loop I have an <code>if condition</code> which checks if my count variable has two or more <code>0</code> in it. If yes we immediately return <code>True</code> .</li> <li>If there is no <code>0</code> value in the array which is passed to the function we go to the next step which is the <code>loop</code> . Here I have the while loop which is running so long until the counter is smaller than the length of the array. In the loop I created another for loop. In there I calculated from the first array the sum of the multiplication with 2 and check with all the elements if there is an element which has the same sum. If yes we return <code>True</code> , if not we add one to the counter and for loop it again with all elements.</li> <li>Now the edge case would be if there is an <code>0</code> in the array since the sum of <code>2 * 0</code> is <code>0</code> so, in the for loop it would return True for the same element which we did the calculation, so I enhanced my if to check as well if my current value from the array is not <code>0</code> . Even if there would be multiple <code>0</code> in the array the first if condition is covering this case so here we would simply don\u2019t care about it.</li> <li>If the loop finishes, and we still would not find any element we would simply return <code>False</code>.</li> </ol> <p>Time Complexity: <code>Big O(n\u00b2)</code>, where <code>n</code> is the number of elements in the array. Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</p>"},{"location":"sorting_searching_problems/duplicate_zeros/","title":"1089. Duplicate Zeros","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given a fixed-length integer array <code>arr</code>, duplicate each occurrence of zero, shifting the remaining elements to the right.</p> <p>Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.</p> <p>Example 1:</p> <pre><code>Input: arr = [1,0,2,3,0,4,5,0]\nOutput: [1,0,0,2,3,0,0,4]\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n</code></pre> <p>In this problem we would need to duplicate the zero elements and shift the elements to the right side, which would mean whenever we duplicate we would pop the last element. Let\u2019s have a more detailed look on my solution:</p> <ol> <li>I created a variable called zeros where I count all the <code>0</code> from the array. Moreover, a second variable was created which stores the length of the array.</li> <li>Now I use an <code>for loop</code> to loop backward over the list starting from the last index and ending on index <code>0</code> . I also decrement by 1 each time.</li> <li>Now I check if my current element plus the variable zeros are smaller than the length of the array. This ensures that we are still in range. If this is the case I shift the element at index <code>i</code> to the right by <code>zeros</code> positions. This ensures that the <code>0</code> is successfully duplicated.</li> <li>In the next step I check if my current element is <code>0</code> and if this is the case I subtract <code>1</code> from the <code>zeros</code> .</li> <li>Last but not least after updating the zeros value I check again the same if condition is my current element plus the variable zeros are smaller than the length of the array. If this is the case I shift the element at index <code>i</code> to the right by <code>zeros</code> positions. This ensures that the <code>0</code> is successfully duplicated.</li> </ol> <p>Big O</p> <ul> <li>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array.</li> <li>Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</li> </ul>"},{"location":"sorting_searching_problems/merge_sorted_array/","title":"88. Merge Sorted Array","text":"<p>Let's have a look on the description of the problem:</p> <p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p> <p>Merge <code>nums1</code> and <code>nums2</code> into a single array sorted in non-decreasing order.</p> <p>The final sorted array should not be returned by the function, but instead be stored inside the array <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p> <p>Example 1:</p> <pre><code>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n</code></pre> <p>For this problem I was mainly thinking outside the box and came to a very elegant solution. Let\u2019s have a deeper look into my solution:</p> <ol> <li>I created a new array where I merge the two arrays together and initialize it as empty for now.</li> <li>Now I shallow copy both of the arrays into my new one and use the python slicing mechanism starting from the first element until the element which is specified. After this I have all the elements which I want in my new array.</li> <li>Next I need to sort the array to have it in order, so I just the built-in python function <code>sort()</code>.</li> <li>In the last step I shallow copy the initial array to the one I created and now the array has the correct reference.</li> </ol> <p>The time and space complexity for this would be <code>Big O(n)</code>.</p>"},{"location":"sorting_searching_problems/valid_mountain_array/","title":"941. Valid Mountain Array","text":"<p>Given an array of integers <code>arr</code>, return <code>true</code> if and only if it is a valid mountain array.</p> <p>Recall that arr is a mountain array if and only if:</p> <ul> <li><code>arr.length &gt;= 3</code></li> <li>There exists some <code>i</code> with <code>0 &lt; i &lt; arr.length - 1</code> such that:</li> <li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li> <li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li> </ul> <p>Example 1:</p> <pre><code>Input: arr = [2,1]\nOutput: false\n</code></pre> <p>In this problem we would need to check each an every element to see when we hit the peak which can\u2019t be the start and as well it can\u2019t be the end. We also need to check that when we find the peak that each next element is smaller then the next one, so we can make sure that we walk down from the peak. Let\u2019s have a more detailed look on my solution:</p> <ol> <li>First we need to check if the length of the array is smaller then 3. If this is the case we can immediately <code>return False</code> .</li> <li>Now we initialize a variable called <code>i</code> which we set to 0 and in the next line we create a <code>while loop</code> where we first check if our <code>i</code> is in the range of the array and that our current element <code>arr[i]</code> is smaller then the next item in the array which would be <code>arr[i+1]</code> . With this check we make sure that we walk the mountain up. If all the condition are met we add one to our <code>i</code> .</li> <li>Next we need to make sure that our top of the mountain is not the first or last element since then it would not be a valid mountain. We check if our variable <code>i</code> is zero or our <code>i</code> is the length of the array. Since we had our first while loop we can make sure that we are at the peak which should be somewhere in the middle of the array, so checking if <code>i</code> is zero or the length of the array would make sure that we have a valid mountain. If after the first while loop our <code>i</code> is <code>0</code> or <code>len(arr) - 1</code> then we <code>return False</code> .</li> <li>As a next step we make a new while loop which again will run until <code>i</code> is in the range of the array and now my current element which is <code>arr[i]</code> needs to be greater then the next element which is <code>arr[i + 1]</code> with that we make sure that we walk down the mountain. If this conditions are met we add one to our <code>i</code> .</li> <li>Last but not least we return <code>True</code> if our <code>i</code> is equal to the <code>len(arr) - 1</code> else <code>False</code>.</li> </ol> <p>Big O</p> <ul> <li>Time Complexity: <code>Big O(n)</code>, where <code>n</code> is the number of elements in the array.</li> <li>Space Complexity: <code>Big O(1)</code> . I did not use any additional space.</li> </ul>"},{"location":"string_problems/first_unique_character_in_a_string/","title":"387. First Unique Character in a String","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given a string\u00a0<code>s</code>,\u00a0find the first non-repeating character in it and return its index. If it does not exist, return\u00a0<code>-1</code>.</p> <p>Example 1:</p> <pre><code>Input: s = \"leetcode\"\nOutput: 0\n</code></pre> <p>In this problem I used more built-in Python stuff which was new for me, but I learned a lot out of it. Let\u2019s have a more detailed look on it:</p> <ol> <li>I defined a counter variable which is using the <code>Counter Python Object</code>. Counter counts the occurrences of each character in the string. This line creates a dictionary-like object where the keys are the characters in the string and the values are their respective counts.</li> <li>Now we create a for loop, but we use the <code>enumerate()</code> function to get both the character and its index in the string. We use the <code>enumerate()</code> function because our counter variable is a dict so a key value store, so we need to check the index of the string character.</li> <li>In my <code>for loop</code> I have an if condition which checks if the value of the current dict element is 1 which would mean that the letter of the string is unique since it only occur once. If this is the case we return the index of this element, if not we return -1.</li> </ol> <p>Time complexity:\u00a0<code>O(N)</code>\u00a0since we go through the string of length\u00a0<code>**N**</code>\u00a0two times.</p> <p>Space complexity:\u00a0<code>O(1)</code>\u00a0because English alphabet contains 26 letters.</p>"},{"location":"string_problems/reverse_integer/","title":"7. Reverse Integer","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given a signed 32-bit integer <code>x</code>, return <code>x</code> with its digits reversed. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-231, 231 - 1]</code>, then return <code>0</code>.</p> <p>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</p> <p>Example 1:</p> <pre><code>Input: x = 123\nOutput: 321\n</code></pre> <p>This problem was really challenging since I do not know how to tackle it. At, first it was important that the value do not go outside the signed 32-bit integer range. Next we need to <code>loop</code> through the <code>int number</code> to get one number at the time. Let\u2019s have a more detailed look on the solution:</p> <ol> <li>First we need to define three variables one which is the maximal 32-bit integer number, one which is the minimal 32-bit number and one which will store our reverse value.</li> <li>Next we create a <code>while loop</code> where we check if my number which I need to reverse is not 0, so it will stop when all elements of the numbers are reverse.</li> <li>In the loop I create an if condition which checks the <code>reversed number</code> if it is still in the range of the min and max 32-bit integer range.</li> <li>If this is not the case we calculate the modulo ten of the number and add the number to the reverse variable. We also multiply the reverse variable with ten so that the new digit is appended to the last place because if we would not do it, it would add up to the current number which would modify the number.</li> <li>In the last step we could divide by ten or use <code>math.trunc</code> to get rid of the last element in our number. We do this so long until we reversed the whole number.</li> </ol> <p>The time complexity would be <code>Big O (log(n))</code> since we always get rid of the last element of our int and as well if we exceed the range of max min integer we would stop. The space Complexity is <code>Big O(1)</code> since we do not use any additional space.</p>"},{"location":"string_problems/reverse_string/","title":"344. Reverse String","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p> <p>You must do this by modifying the input array in-place with <code>O(1)</code> extra memory.</p> <p>Example 1:</p> <pre><code>Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</code></pre> <p>In this problem we have the constraint that we are not able to use an additional array to store the values of the array. This constraint leads me to the conclusion that we would need <code>two pointers</code>. One is looking on the first item in the array and one on the last. They would <code>swap</code> so long until they find themselves in the middle. Let\u2019s have a more detail look on the solution:</p> <ol> <li>First I create <code>two pointers</code> called left and right, one is pointing to the <code>first element</code> which has the index 0 and the second one on the <code>last element</code> which is the length of the array minus one.</li> <li>Now I created a while <code>loop</code> with the <code>condition</code> to run so long until left is bigger than right which would mean that they are in the middle.</li> <li>In the loop I am swapping my left element with my right element and the right element is my new left element. After this is done I add up to the left index one and subtract from the right index one so that they come closer to each other.</li> </ol> <p>Time complexity of this solution would be <code>Big O(n)</code> since we travers the array only once and even not fully since in the middle of it we stop. For the Space Complexity we are on <code>Big O(1)</code> since we did not use any additional space.</p> <p>There is even a much easier solution to this, a one linear if you would think of it. We could just use the <code>built-in reverse function</code> from python, and it would as well solve it.</p>"},{"location":"string_problems/valid_anagram/","title":"242. Valid Anagram","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an anagram of <code>s</code>, and <code>false</code> otherwise.</p> <p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p> <p>Example 1:</p> <pre><code>Input: s = \"anagram\", t = \"nagaram\"\nOutput: true\n</code></pre> <p>In this problem we need to check if the two inputs which we get are a valid anagram. My approach of it was just adding both words in separate arrays, sort them and if they are equal we would return <code>True</code> otherwise <code>False</code> . Let\u2019s have a more detailed look into my solution:</p> <ol> <li>As mentioned before in the first step I create two empty arrays.</li> <li>In the next step I create two <code>for loops</code> which are not nested, in the first loop I loop through the first word and append every letter to one of the array. In the second loop I loop through the second word and append it to the array. Now I have in the two arrays every letter of the two words.</li> <li>Now I just call the built-in method of python <code>sort()</code> on both of the arrays. This is needed because if the word is an anagram sorting it will be in the correct order and would have the letters on the same index.</li> <li>In the end I just have an if condition, if array one is the same as array 2 and if so, I would return <code>True</code> otherwise <code>False</code>.</li> </ol> <p>The time complexity here is <code>Big O(n)</code> and space complexity is as well <code>Big O(n)</code>.</p>"},{"location":"string_problems/valid_palindrome/","title":"125. Valid Palindrome","text":"<p>Let\u2019s have a look on the description of the problem:</p> <p>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p> <p>Given a string <code>s</code>, return <code>true</code> if it is a palindrome, or <code>false</code> otherwise.</p> <p>Example 1:</p> <pre><code>Input: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n</code></pre> <p>In this problem we need to check the <code>string</code> if it is a Palindrome, which means the string needs to be the same as reversed and not reversed. For that problem we need two pointers because we need to look on the first index of the string and the second one will look on the last index and what we basically do it we compare the first index which the last one if there are the same we add to the first index one and to the last index the subtract one. We do this process until we are in the middle of it and if all the characters are the same we know it's a Palindrome since we could switch them and still the same would be the outcome. Let\u2019s have a more detailed look on my solution:</p> <ol> <li>First we create two pointers, one has the value zero since it will have a look on our first index and the second one will have the value length of the array minus one to get the actual last index.</li> <li>Now we create a <code>while loop</code> which will run so long until our first pointer which is looking on the first index is bigger then the second pointer which is looking on our last index.</li> <li>In this while we have to create the two additional <code>while loops</code> to check if the current character is an alphabetical character, if it is we just skip it and add to the index one more and to the second pointer the subtract one.</li> <li>If one of the elements is not same for both counter we stop the loop and return <code>false</code> if our loop finishes we return <code>true</code> since all the characters are the same.</li> </ol> <p>This solution has time complexity of <code>Big O(n)</code> where n the length of the string is. There is no additional space needed so the space complexity would be <code>Big O(1)</code>.</p>"}]}